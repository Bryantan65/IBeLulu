# IBM watsonx Orchestrate - Complete Setup Guide

> ⚠️ **ARCHIVED DOCUMENTATION**  
> This guide documents the initial setup process. The project has been migrated to use **Supabase Edge Functions** for JWT generation.  
> See [DEPLOYMENT_GUIDE.md](DEPLOYMENT_GUIDE.md) for current deployment instructions.

**Complete guide for setting up authenticated embedded chat with IBM watsonx Orchestrate**

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Security Configuration](#security-configuration)
4. [JWT Token Generation](#jwt-token-generation)
5. [Embedding the Chat](#embedding-the-chat)
6. [Troubleshooting](#troubleshooting)
7. [Production Deployment](#production-deployment)

---

## Overview

This guide documents the complete process of setting up IBM watsonx Orchestrate embedded chat with **RS256 JWT authentication** and **RSA encryption**. This setup ensures secure, production-ready authentication for your embedded AI agents.

### Security Architecture

The system uses **two RSA key pairs**:

1. **IBM Key Pair** (Generated by watsonx Orchestrate)
   - **IBM Public Key**: Used by your app to encrypt sensitive user data
   - **IBM Private Key**: Stored by watsonx, used to decrypt user data

2. **Client Key Pair** (Generated by you)
   - **Client Private Key**: Used to sign JWTs (keep this SECRET!)
   - **Client Public Key**: Shared with watsonx to verify JWT signatures

---

## Prerequisites

### Required Tools

- **Python 3.12** with pip
- **OpenSSL** (for key generation)
- **jq** (JSON processor for bash script)
- **Bash shell** (Git Bash on Windows, or WSL)

### Required Information

From your watsonx Orchestrate instance:
- Service Instance URL
- API Key (for IBM Cloud/AWS) or CPD credentials
- Agent ID
- Agent Environment ID

---

## Security Configuration

### Step 1: Get the Security Configuration Tool

Save the following script as `wxO-embed-chat-security-tool.sh`:

```bash
# The complete script is already in your project
# Location: wxO-embed-chat-security-tool.sh
```

### Step 2: Make the Script Executable

**On Linux/Mac:**
```bash
chmod +x wxO-embed-chat-security-tool.sh
```

**On Windows (WSL):**
```bash
cd "/mnt/c/Users/Bryan/Desktop/IBeLuLu Hackathon/IBeLulu"
chmod +x wxO-embed-chat-security-tool.sh
```

### Step 3: Run the Security Tool

```bash
./wxO-embed-chat-security-tool.sh
```

**What this does:**
1. Prompts for your Service Instance URL
2. Authenticates with your watsonx instance
3. Generates RSA key pairs (4096-bit)
4. Configures security on your instance
5. Saves keys to `./keys/` directory

**Generated Files:**
```
keys/
├── example-jwtRS256.key        # Client PRIVATE key (KEEP SECRET!)
├── example-jwtRS256.key.pub    # Client PUBLIC key
└── ibmPublic.key.pub           # IBM PUBLIC key
```

### Step 4: Protect Your Keys

Add to `.gitignore`:
```gitignore
# Security keys - NEVER COMMIT THESE
keys/
*.key
*.pem
token.txt
jwt_output.txt
```

---

## JWT Token Generation

### Python Implementation

#### 1. Install Dependencies

```bash
pip install PyJWT cryptography
```

Add to `requirements.txt`:
```
ibm-watsonx-orchestrate
PyJWT
cryptography
Flask
Flask-CORS
```

#### 2. Create JWT Generator (`jwt_generator.py`)

**Key Features:**
- RS256 signing with your private key
- RSA-OAEP encryption with SHA256 for user payload
- Proper JWT structure matching watsonx requirements

**Critical Implementation Details:**

```python
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
import jwt
import json
import base64

class WatsonxJWTGenerator:
    def __init__(self, private_key_path, ibm_public_key_path):
        # Load your private key for signing
        with open(private_key_path, 'rb') as f:
            self.private_key = serialization.load_pem_private_key(
                f.read(), password=None
            )
        
        # Load IBM's public key for encryption
        with open(ibm_public_key_path, 'rb') as f:
            self.ibm_public_key = serialization.load_pem_public_key(f.read())
    
    def encrypt_user_payload(self, user_data):
        """Encrypt user data with IBM's public key"""
        user_json = json.dumps(user_data)
        user_bytes = user_json.encode('utf-8')
        
        # CRITICAL: Use OAEP padding with SHA256
        encrypted = self.ibm_public_key.encrypt(
            user_bytes,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return base64.b64encode(encrypted).decode('utf-8')
    
    def generate_token(self, user_id, user_data=None, context=None, expires_in_hours=24):
        """Generate signed JWT token"""
        payload = {
            'sub': user_id,  # User identifier
        }
        
        # Add encrypted user_payload
        if user_data:
            payload['user_payload'] = self.encrypt_user_payload(user_data)
        
        # Add context (NOT encrypted, accessible by agent)
        if context:
            payload['context'] = context
        
        # Add timestamps
        now = datetime.utcnow()
        payload['iat'] = int(now.timestamp())
        payload['exp'] = int((now + timedelta(hours=expires_in_hours)).timestamp())
        
        # Sign with RS256
        token = jwt.encode(payload, self.private_key, algorithm='RS256')
        return token
```

#### 3. JWT Structure

**Required Fields:**

```json
{
  "sub": "user-unique-id",           // Subject (user ID)
  "iat": 1234567890,                 // Issued at (timestamp)
  "exp": 1234654290,                 // Expiration (timestamp)
  "user_payload": "base64encrypted", // Encrypted user data
  "context": {                       // NOT encrypted, accessible by agent
    "dev_id": 12345,
    "dev_name": "User Name",
    "is_active": true
  }
}
```

**Important Notes:**
- `user_payload` is **encrypted** with IBM's public key
- `context` is **NOT encrypted** and accessible by the agent
- Token is **signed** with your private key using RS256

---

## Embedding the Chat

### Critical Configuration

The embedded chat requires specific configuration structure:

#### ❌ WRONG (Will cause 401 errors):

```javascript
window.wxOConfiguration = {
    chatOptions: {
        identityToken: token  // ❌ Wrong location
    }
};
```

#### ✅ CORRECT:

```javascript
window.wxOConfiguration = {
    orchestrationID: "your-org-id_orchestration-id",
    hostURL: "https://ap-southeast-1.dl.watson-orchestrate.ibm.com",
    rootElementID: "root",
    
    // Token at ROOT level
    token: currentToken,  // ✅ Correct location
    
    chatOptions: {
        agentId: "your-agent-id",
        agentEnvironmentId: "your-agent-env-id"  // ✅ Required!
    },
    
    // Token refresh handler
    onAuthTokenNeeded: async function() {
        return await fetchToken();  // ✅ Must return fresh token
    }
};
```

### Complete HTML Implementation

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>watsonx Orchestrate Chat</title>
</head>
<body>
    <div id="root"></div>

    <script>
        let currentToken = null;
        
        // Fetch token from your backend
        async function fetchToken() {
            const response = await fetch('/api/token');
            const data = await response.json();
            currentToken = data.token;
            return currentToken;
        }
        
        // Initialize chat
        async function initChat() {
            await fetchToken();
            
            window.wxOConfiguration = {
                orchestrationID: "YOUR_ORCHESTRATION_ID",
                hostURL: "YOUR_HOST_URL",
                rootElementID: "root",
                token: currentToken,
                chatOptions: {
                    agentId: "YOUR_AGENT_ID",
                    agentEnvironmentId: "YOUR_AGENT_ENV_ID"
                },
                onAuthTokenNeeded: async function() {
                    console.log('Token refresh requested');
                    return await fetchToken();
                }
            };
            
            const script = document.createElement('script');
            script.src = `${window.wxOConfiguration.hostURL}/wxochat/wxoLoader.js?embed=true`;
            script.addEventListener('load', () => wxoLoader.init());
            document.head.appendChild(script);
        }
        
        initChat();
    </script>
</body>
</html>
```

### Flask Backend Example

```python
from flask import Flask, jsonify
from jwt_generator import WatsonxJWTGenerator

app = Flask(__name__)

generator = WatsonxJWTGenerator(
    private_key_path='keys/example-jwtRS256.key',
    ibm_public_key_path='keys/ibmPublic.key.pub'
)

@app.route('/api/token')
def get_token():
    user_id = "demo-user-123"
    
    user_data = {
        "name": "Demo User",
        "email": "demo@example.com",
        "custom_message": "Encrypted data"
    }
    
    context = {
        "dev_id": 12345,
        "dev_name": "Demo User",
        "is_active": True
    }
    
    token = generator.generate_token(user_id, user_data, context)
    
    return jsonify({
        "token": token,
        "user_id": user_id
    })

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

---

## Troubleshooting

### Common Errors and Solutions

#### 1. **401 Unauthorized Error**

**Symptoms:**
```
Failed to load resource: the server responded with a status of 401
Error: The authTokenNeeded event was emitted but no new token was provided
```

**Solutions:**
- ✅ Ensure `token` is at **root level** of `wxOConfiguration`
- ✅ Implement `onAuthTokenNeeded` callback
- ✅ Verify `agentEnvironmentId` is included
- ✅ Check that JWT is properly signed with your private key
- ✅ Confirm client public key is configured on watsonx instance

#### 2. **"There was an error processing this message"**

**Possible Causes:**
- Missing `agentEnvironmentId`
- Incorrect JWT structure
- Encryption mismatch (wrong padding or hash algorithm)
- Token expired

**Solutions:**
- ✅ Add `agentEnvironmentId` to `chatOptions`
- ✅ Verify JWT includes: `sub`, `iat`, `exp`, `user_payload`, `context`
- ✅ Use OAEP padding with SHA256 for encryption
- ✅ Generate fresh token

#### 3. **Chat Doesn't Load**

**Check:**
- ✅ `rootElementID` matches your HTML element ID
- ✅ Script URL is correct for your region
- ✅ No CORS errors in browser console
- ✅ Token is fetched before initializing chat

### Debugging Tips

**Enable Console Logging:**
```javascript
console.log('Token:', currentToken);
console.log('Config:', window.wxOConfiguration);
```

**Check JWT Payload:**
```python
import jwt
decoded = jwt.decode(token, options={"verify_signature": False})
print(json.dumps(decoded, indent=2))
```

**Verify Keys:**
```bash
# Check if keys are valid PEM format
openssl rsa -in keys/example-jwtRS256.key -check
openssl rsa -pubin -in keys/ibmPublic.key.pub -text
```

---

## Production Deployment

### Security Checklist

- [ ] **Never commit private keys to Git**
- [ ] **Use environment variables for sensitive data**
- [ ] **Enable HTTPS** (required for production)
- [ ] **Set appropriate token expiration** (e.g., 1 hour instead of 24)
- [ ] **Implement proper session management**
- [ ] **Add rate limiting** to token endpoint
- [ ] **Monitor token refresh requests**
- [ ] **Rotate keys periodically**

### Environment Variables

```bash
# .env file
WXO_PRIVATE_KEY_PATH=/secure/path/to/private.key
WXO_IBM_PUBLIC_KEY_PATH=/secure/path/to/ibm_public.key
WXO_ORCHESTRATION_ID=your-orchestration-id
WXO_HOST_URL=https://your-region.watson-orchestrate.ibm.com
WXO_AGENT_ID=your-agent-id
WXO_AGENT_ENV_ID=your-agent-env-id
```

### Production Flask Configuration

```python
import os
from flask import Flask
from flask_cors import CORS

app = Flask(__name__)

# Production settings
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
CORS(app, origins=['https://yourdomain.com'])

# Use environment variables
PRIVATE_KEY_PATH = os.environ.get('WXO_PRIVATE_KEY_PATH')
IBM_PUBLIC_KEY_PATH = os.environ.get('WXO_IBM_PUBLIC_KEY_PATH')
```

### Deployment Options

1. **Heroku**: Use environment variables for keys
2. **AWS**: Store keys in AWS Secrets Manager
3. **Docker**: Mount keys as secrets
4. **Azure**: Use Azure Key Vault

---

## Quick Reference

### Get Agent Configuration

```bash
orchestrate channels webchat embed --agent-name=Your_Agent_Name
```

### Generate New Token

```python
from jwt_generator import WatsonxJWTGenerator

generator = WatsonxJWTGenerator(
    'keys/example-jwtRS256.key',
    'keys/ibmPublic.key.pub'
)

token = generator.generate_token(
    user_id="user-123",
    user_data={"name": "John Doe"},
    context={"role": "admin"}
)
```

### Test Token Locally

```bash
python generate_token.py
# Token saved to token.txt
```

### Start Flask Server

```bash
python app.py
# Server runs on http://localhost:5000
```

---

## Additional Resources

- [IBM watsonx Orchestrate Documentation](https://developer.watson-orchestrate.ibm.com)
- [JWT.io Debugger](https://jwt.io) - Decode and verify JWTs
- [OpenSSL Documentation](https://www.openssl.org/docs/)

---

## Support

For issues or questions:
1. Check the [Troubleshooting](#troubleshooting) section
2. Review browser console for errors
3. Verify JWT structure and encryption
4. Check watsonx Orchestrate logs

---

**Last Updated:** January 27, 2026  
**Version:** 1.0  
**Status:** Production Ready ✅

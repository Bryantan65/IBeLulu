# IBM watsonx Orchestrate - Complete Setup Guide

> ⚠️ **ARCHIVED DOCUMENTATION**  
> This guide documents the initial setup process. The project has been migrated to use **Supabase Edge Functions** for JWT generation.  
> See [DEPLOYMENT_GUIDE.md](DEPLOYMENT_GUIDE.md) for current deployment instructions.

**Complete guide for setting up authenticated embedded chat with IBM watsonx Orchestrate**

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Security Configuration](#security-configuration)
4. [JWT Token Generation](#jwt-token-generation)
5. [Embedding the Chat](#embedding-the-chat)
6. [Troubleshooting](#troubleshooting)
7. [Production Deployment](#production-deployment)
8. [Advanced Integrations: Database & MCP](#advanced-integrations-database--mcp)
9. [Appendix: MCP Proxy Setup](#appendix-mcp-proxy-setup)

---

## Overview

This guide documents the complete process of setting up IBM watsonx Orchestrate embedded chat with **RS256 JWT authentication** and **RSA encryption**. This setup ensures secure, production-ready authentication for your embedded AI agents.

### Security Architecture

The system uses **two RSA key pairs**:

1. **IBM Key Pair** (Generated by watsonx Orchestrate)
   - **IBM Public Key**: Used by your app to encrypt sensitive user data
   - **IBM Private Key**: Stored by watsonx, used to decrypt user data

2. **Client Key Pair** (Generated by you)
   - **Client Private Key**: Used to sign JWTs (keep this SECRET!)
   - **Client Public Key**: Shared with watsonx to verify JWT signatures

---

## Prerequisites

### Required Tools

- **Python 3.12** with pip
- **OpenSSL** (for key generation)
- **jq** (JSON processor for bash script)
- **Bash shell** (Git Bash on Windows, or WSL)

### Required Information

From your watsonx Orchestrate instance:
- Service Instance URL
- API Key (for IBM Cloud/AWS) or CPD credentials
- Agent ID
- Agent Environment ID

---

## Security Configuration

### Step 1: Get the Security Configuration Tool

Save the following script as `wxO-embed-chat-security-tool.sh`:

```bash
# The complete script is already in your project
# Location: wxO-embed-chat-security-tool.sh
```

### Step 2: Make the Script Executable

**On Linux/Mac:**
```bash
chmod +x wxO-embed-chat-security-tool.sh
```

**On Windows (WSL):**
```bash
cd "/mnt/c/Users/Bryan/Desktop/IBeLuLu Hackathon/IBeLuLu"
chmod +x wxO-embed-chat-security-tool.sh
```

### Step 3: Run the Security Tool

```bash
./wxO-embed-chat-security-tool.sh
```

**What this does:**
1. Prompts for your Service Instance URL
2. Authenticates with your watsonx instance
3. Generates RSA key pairs (4096-bit)
4. Configures security on your instance
5. Saves keys to `./keys/` directory

**Generated Files:**
```
keys/
├── example-jwtRS256.key        # Client PRIVATE key (KEEP SECRET!)
├── example-jwtRS256.key.pub    # Client PUBLIC key
└── ibmPublic.key.pub           # IBM PUBLIC key
```

### Step 4: Protect Your Keys

Add to `.gitignore`:
```gitignore
# Security keys - NEVER COMMIT THESE
keys/
*.key
*.pem
token.txt
jwt_output.txt
```

---

## JWT Token Generation

### Python Implementation

#### 1. Install Dependencies

```bash
pip install PyJWT cryptography
```

Add to `requirements.txt`:
```
ibm-watsonx-orchestrate
PyJWT
cryptography
Flask
Flask-CORS
```

#### 2. Create JWT Generator (`jwt_generator.py`)

**Key Features:**
- RS256 signing with your private key
- RSA-OAEP encryption with SHA256 for user payload
- Proper JWT structure matching watsonx requirements

**Critical Implementation Details:**

```python
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
import jwt
import json
import base64

class WatsonxJWTGenerator:
    def __init__(self, private_key_path, ibm_public_key_path):
        # Load your private key for signing
        with open(private_key_path, 'rb') as f:
            self.private_key = serialization.load_pem_private_key(
                f.read(), password=None
            )
        
        # Load IBM's public key for encryption
        with open(ibm_public_key_path, 'rb') as f:
            self.ibm_public_key = serialization.load_pem_public_key(f.read())
    
    def encrypt_user_payload(self, user_data):
        """Encrypt user data with IBM's public key"""
        user_json = json.dumps(user_data)
        user_bytes = user_json.encode('utf-8')
        
        # CRITICAL: Use OAEP padding with SHA256
        encrypted = self.ibm_public_key.encrypt(
            user_bytes,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        return base64.b64encode(encrypted).decode('utf-8')
    
    def generate_token(self, user_id, user_data=None, context=None, expires_in_hours=24):
        """Generate signed JWT token"""
        payload = {
            'sub': user_id,  # User identifier
        }
        
        # Add encrypted user_payload
        if user_data:
            payload['user_payload'] = self.encrypt_user_payload(user_data)
        
        # Add context (NOT encrypted, accessible by agent)
        if context:
            payload['context'] = context
        
        # Add timestamps
        now = datetime.utcnow()
        payload['iat'] = int(now.timestamp())
        payload['exp'] = int((now + timedelta(hours=expires_in_hours)).timestamp())
        
        # Sign with RS256
        token = jwt.encode(payload, self.private_key, algorithm='RS256')
        return token
```

#### 3. JWT Structure

**Required Fields:**

```json
{
  "sub": "user-unique-id",           // Subject (user ID)
  "iat": 1234567890,                 // Issued at (timestamp)
  "exp": 1234654290,                 // Expiration (timestamp)
  "user_payload": "base64encrypted", // Encrypted user data
  "context": {                       // NOT encrypted, accessible by agent
    "dev_id": 12345,
    "dev_name": "User Name",
    "is_active": true
  }
}
```

**Important Notes:**
- `user_payload` is **encrypted** with IBM's public key
- `context` is **NOT encrypted** and accessible by the agent
- Token is **signed** with your private key using RS256

---

## Embedding the Chat

### Critical Configuration

The embedded chat requires specific configuration structure:

#### ❌ WRONG (Will cause 401 errors):

```javascript
window.wxOConfiguration = {
    chatOptions: {
        identityToken: token  // ❌ Wrong location
    }
};
```

#### ✅ CORRECT:

```javascript
window.wxOConfiguration = {
    orchestrationID: "your-org-id_orchestration-id",
    hostURL: "https://ap-southeast-1.dl.watson-orchestrate.ibm.com",
    rootElementID: "root",
    
    // Token at ROOT level
    token: currentToken,  // ✅ Correct location
    
    chatOptions: {
        agentId: "your-agent-id",
        agentEnvironmentId: "your-agent-env-id"  // ✅ Required!
    },
    
    // Token refresh handler
    onAuthTokenNeeded: async function() {
        return await fetchToken();  // ✅ Must return fresh token
    }
};
```

### Complete HTML Implementation

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>watsonx Orchestrate Chat</title>
</head>
<body>
    <div id="root"></div>

    <script>
        let currentToken = null;
        
        // Fetch token from your backend
        async function fetchToken() {
            const response = await fetch('/api/token');
            const data = await response.json();
            currentToken = data.token;
            return currentToken;
        }
        
        // Initialize chat
        async function initChat() {
            await fetchToken();
            
            window.wxOConfiguration = {
                orchestrationID: "YOUR_ORCHESTRATION_ID",
                hostURL: "YOUR_HOST_URL",
                rootElementID: "root",
                token: currentToken,
                chatOptions: {
                    agentId: "YOUR_AGENT_ID",
                    agentEnvironmentId: "YOUR_AGENT_ENV_ID"
                },
                onAuthTokenNeeded: async function() {
                    console.log('Token refresh requested');
                    return await fetchToken();
                }
            };
            
            const script = document.createElement('script');
            script.src = `${window.wxOConfiguration.hostURL}/wxochat/wxoLoader.js?embed=true`;
            script.addEventListener('load', () => wxoLoader.init());
            document.head.appendChild(script);
        }
        
        initChat();
    </script>
</body>
</html>
```

### Flask Backend Example

```python
from flask import Flask, jsonify
from jwt_generator import WatsonxJWTGenerator

app = Flask(__name__)

generator = WatsonxJWTGenerator(
    private_key_path='keys/example-jwtRS256.key',
    ibm_public_key_path='keys/ibmPublic.key.pub'
)

@app.route('/api/token')
def get_token():
    user_id = "demo-user-123"
    
    user_data = {
        "name": "Demo User",
        "email": "demo@example.com",
        "custom_message": "Encrypted data"
    }
    
    context = {
        "dev_id": 12345,
        "dev_name": "Demo User",
        "is_active": True
    }
    
    token = generator.generate_token(user_id, user_data, context)
    
    return jsonify({
        "token": token,
        "user_id": user_id
    })

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

---

## Troubleshooting

### Common Errors and Solutions

#### 1. **401 Unauthorized Error**

**Symptoms:**
```
Failed to load resource: the server responded with a status of 401
Error: The authTokenNeeded event was emitted but no new token was provided
```

**Solutions:**
- ✅ Ensure `token` is at **root level** of `wxOConfiguration`
- ✅ Implement `onAuthTokenNeeded` callback
- ✅ Verify `agentEnvironmentId` is included
- ✅ Check that JWT is properly signed with your private key
- ✅ Confirm client public key is configured on watsonx instance

#### 2. **"There was an error processing this message"**

**Possible Causes:**
- Missing `agentEnvironmentId`
- Incorrect JWT structure
- Encryption mismatch (wrong padding or hash algorithm)
- Token expired

**Solutions:**
- ✅ Add `agentEnvironmentId` to `chatOptions`
- ✅ Verify JWT includes: `sub`, `iat`, `exp`, `user_payload`, `context`
- ✅ Use OAEP padding with SHA256 for encryption
- ✅ Generate fresh token

#### 3. **Chat Doesn't Load**

**Check:**
- ✅ `rootElementID` matches your HTML element ID
- ✅ Script URL is correct for your region
- ✅ No CORS errors in browser console
- ✅ Token is fetched before initializing chat

### Debugging Tips

**Enable Console Logging:**
```javascript
console.log('Token:', currentToken);
console.log('Config:', window.wxOConfiguration);
```

**Check JWT Payload:**
```python
import jwt
decoded = jwt.decode(token, options={"verify_signature": False})
print(json.dumps(decoded, indent=2))
```

**Verify Keys:**
```bash
# Check if keys are valid PEM format
openssl rsa -in keys/example-jwtRS256.key -check
openssl rsa -pubin -in keys/ibmPublic.key.pub -text
```

---

## Production Deployment

### Security Checklist

- [ ] **Never commit private keys to Git**
- [ ] **Use environment variables for sensitive data**
- [ ] **Enable HTTPS** (required for production)
- [ ] **Set appropriate token expiration** (e.g., 1 hour instead of 24)
- [ ] **Implement proper session management**
- [ ] **Add rate limiting** to token endpoint
- [ ] **Monitor token refresh requests**
- [ ] **Rotate keys periodically**

### Environment Variables

```bash
# .env file
WXO_PRIVATE_KEY_PATH=/secure/path/to/private.key
WXO_IBM_PUBLIC_KEY_PATH=/secure/path/to/ibm_public.key
WXO_ORCHESTRATION_ID=your-orchestration-id
WXO_HOST_URL=https://your-region.watson-orchestrate.ibm.com
WXO_AGENT_ID=your-agent-id
WXO_AGENT_ENV_ID=your-agent-env-id
```

### Production Flask Configuration

```python
import os
from flask import Flask
from flask_cors import CORS

app = Flask(__name__)

# Production settings
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
CORS(app, origins=['https://yourdomain.com'])

# Use environment variables
PRIVATE_KEY_PATH = os.environ.get('WXO_PRIVATE_KEY_PATH')
IBM_PUBLIC_KEY_PATH = os.environ.get('WXO_IBM_PUBLIC_KEY_PATH')
```

### Deployment Options

1. **Heroku**: Use environment variables for keys
2. **AWS**: Store keys in AWS Secrets Manager
3. **Docker**: Mount keys as secrets
4. **Azure**: Use Azure Key Vault

---

## Quick Reference

### Get Agent Configuration

```bash
orchestrate channels webchat embed --agent-name=Your_Agent_Name
```

### Generate New Token

```python
from jwt_generator import WatsonxJWTGenerator

generator = WatsonxJWTGenerator(
    'keys/example-jwtRS256.key',
    'keys/ibmPublic.key.pub'
)

token = generator.generate_token(
    user_id="user-123",
    user_data={"name": "John Doe"},
    context={"role": "admin"}
)
```

### Test Token Locally

```bash
python generate_token.py
# Token saved to token.txt
```

### Start Flask Server

```bash
python app.py
# Server runs on http://localhost:5000
```

---

## 8. Advanced Integrations: Database & MCP

During the implementation of sophisticated agents that need to interact with external databases (like Supabase), we established clear architectural best practices for when to use the generic Model Context Protocol (MCP) versus custom OpenAPI tools.

### 8.1 The "Read vs. Write" Paradigm

When integrating databases with watsonx agents, use this decision framework:

| Feature | **Model Context Protocol (MCP)** | **OpenAPI + Edge Functions** |
| :--- | :--- | :--- |
| **Primary Use Case** | **Exploration & Reading** (Read-Only) | **Transactions & Business Logic** (Write/Execute) |
| **Agent Role** | "Analyst" discovering data schema | "Operator" executing a specific task |
| **Reliability** | **Medium** - Relies on LLM writing SQL | **High** - Relies on deterministic code |
| **Complexity** | High prompt engineering required | Low prompt engineering (Simple tool call) |
| **Example** | "List all tables", "Check recent logs" | "Submit a complaint", "Process a refund" |

### 8.2 Why MCP Struggles with Writes

Using a generic MCP connection (e.g., Supabase MCP) gives the agent "Generic Tools" like `execute_sql` or `list_tables`.
*   **The Problem:** To perform a complex write (e.g., *Triage a complaint -> Insert into DB -> Log to Audit -> Notify User*), the LLM must effectively become a database administrator using prompts alone.
*   **The Failure Mode:** The LLM often "hallucinates" convenience functions (e.g., calling `update_triage()` which doesn't exist) or fails to format complex SQL `INSERT` statements correctly (specifically escaping quotes and handling JSON types).

### 8.3 The Recommended Architecture: Edge Functions

For robust agent actions, move the business logic **out of the Prompt and into Code**.

1.  **Create a Specific Endpoint:**
    Instead of asking the LLM to `INSERT INTO complaints...`, create a serverless function (e.g., Supabase Edge Function) that exposes a single action: `submit-complaint`.

2.  **Define Rigid Inputs (OpenAPI):**
    Use an OpenAPI specification to define exactly what the agent must provide.
    ```yaml
    /submit-complaint:
      post:
        requestBody:
          content:
            application/json:
              schema:
                properties:
                  category: { type: string }
                  severity: { type: integer }
                  text: { type: string }
    ```

3.  **Handle Logic in Code:**
    The Edge Function handles the details:
    *   Validating inputs
    *   Inserting into multiple tables (transactions)
    *   Handling formatting and types
    *   Returning a simple "Success" message

### 8.4 Implementation Checklist

When adding a new capability to your agent:
- [ ] **Is it a unique, complex action?** -> Build an Edge Function + OpenAPI.
- [ ] **Is it a simple query or exploration?** -> Use MCP.
- [ ] **Does it require strict data validation?** -> specific Tool (OpenAPI) is mandatory.

This "Specific Tool" approach prevents the agent from struggling with syntax and allows it to focus on its primary reasoning tasks (Triage, Classification, Empathy).

---

## 9. Appendix: MCP Proxy Setup

This section details how to set up the authentication proxy required for connecting generic MCP clients (like watsonx) to Supabase MCP, which requires custom headers.

### 9.1 The Problem
watsonx Orchestrate cannot directly connect to Supabase MCP because:
1.  Supabase MCP requires `Authorization: Bearer sbp_...` on ALL requests.
2.  watsonx Orchestrate's "Add remote MCP server" UI doesn't support custom headers.
3.  No "Generic HTTP" or "Bearer Token" option is available in the simple connection dropdown.

### 9.2 The Solution: Cloudflare Worker Proxy
We deploy a lightweight authentication proxy that accepts unauthenticated requests from watsonx and injects the Supabase PAT before forwarding to Supabase.

#### Architecture
```
[watsonx Orchestrate] --HTTP--> [Cloudflare Worker Proxy] --HTTP+Auth--> [Supabase MCP Server]
(No Auth)                      (Injects PAT)                             (Verified)
```

### 9.3 Deployment Steps

#### 1. Requirements
- Wrangler CLI (`npm install -g wrangler`)
- Cloudflare Account
- Supabase Project Ref & PAT (Personal Access Token)

#### 2. Configuration (`wrangler.toml`)
Ensure your `wrangler.toml` is configured (see `mcp-proxy/wrangler.toml`).

#### 3. Set Secrets
**Never hardcode secrets in code.** Use Cloudflare's encrypted secret storage:
```bash
wrangler secret put SUPABASE_PROJECT_REF  # Enter your project ref
wrangler secret put SUPABASE_PAT          # Enter your Supabase PAT
```

#### 4. Deploy
```bash
cd mcp-proxy
npm install
wrangler deploy
```
Copy the resulting URL (e.g., `https://supabase-mcp-proxy.your-subdomain.workers.dev`).

#### 5. Configure in watsonx
1.  Go to **Integrations → MCP Servers**.
2.  Click **Add remote MCP server**.
3.  URL: `https://supabase-mcp-proxy.your-subdomain.workers.dev`
4.  Authentication: **None** (The proxy handles it).

### 9.4 Security Checklist
- [ ] **Use Read-Only PAT**: The Supabase token should only have read permissions if the agent is only reading data.
- [ ] **Rate Limiting**: The proxy implementation (in `mcp-proxy/supabase-mcp-proxy.js`) should implement rate limits to prevent abuse.
- [ ] **Monitoring**: Check Cloudflare analytics regularly for unusual traffic.

For full implementation details, see `mcp-proxy/README.md`.

---

## Additional Resources

- [IBM watsonx Orchestrate Documentation](https://developer.watson-orchestrate.ibm.com)
- [JWT.io Debugger](https://jwt.io) - Decode and verify JWTs
- [OpenSSL Documentation](https://www.openssl.org/docs/)

---

## Support

For issues or questions:
1. Check the [Troubleshooting](#troubleshooting) section
2. Review browser console for errors
3. Verify JWT structure and encryption
4. Check watsonx Orchestrate logs

---

**Last Updated:** January 27, 2026
**Version:** 1.2
**Status:** Production Ready ✅
